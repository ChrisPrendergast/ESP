<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>replit</title>
    <link href="style.css" rel="stylesheet" type="text/css" />
    <img id="beach" width="32" height="32" src="images/beach.png">
    <img id="botbeach" width="32" height="32" src="images/botbeach.png">
    <img id="botbeach2" width="32" height="32" src="images/botbeach2.png">
    <img id="botgrass" width="32" height="32" src="images/botgrass.png">
    <img id="botleftgrass" width="32" height="32" src="images/botleftgrass.png">
    <img id="botlefttundra" width="32" height="32" src="images/botlefttundra.png">
    <img id="botleftwater" width="32" height="32" src="images/botleftwater.png">
    <img id="botleftwater2" width="32" height="32" src="images/botleftwater2.png">
    <img id="botleftwater3" width="32" height="32" src="images/botleftwater3.png">
    <img id="botrightgrass" width="32" height="32" src="images/botrightgrass.png">
    <img id="botrighttundra" width="32" height="32" src="images/botrighttundra.png">
    <img id="botrightwater" width="32" height="32" src="images/botrightwater.png">
    <img id="botrightwater2" width="32" height="32" src="images/botrightwater2.png">
    <img id="botrightwater3" width="32" height="32" src="images/botrightwater3.png">
    <img id="bottundra" width="32" height="32" src="images/bottundra.png">
    <img id="botwater" width="32" height="32" src="images/botwater.png">
    <img id="botwater2" width="32" height="32" src="images/botwater2.png">
    <img id="botwater3" width="32" height="32" src="images/botwater3.png">
    <img id="deepwater" width="32" height="32" src="images/deepwater.png">
    <img id="grass" width="32" height="32" src="images/grass.png">
    <img id="leftbeach" width="32" height="32" src="images/leftbeach.png">
    <img id="leftbeach2" width="32" height="32" src="images/leftbeach2.png">
    <img id="leftgrass" width="32" height="32" src="images/leftgrass.png">
    <img id="lefttundra" width="32" height="32" src="images/lefttundra.png">
    <img id="leftwater" width="32" height="32" src="images/leftwater.png">
    <img id="leftwater2" width="32" height="32" src="images/leftwater2.png">
    <img id="leftwater3" width="32" height="32" src="images/leftwater3.png">
    <img id="rightbeach" width="32" height="32" src="images/rightbeach.png">
    <img id="rightbeach2" width="32" height="32" src="images/rightbeach2.png">
    <img id="rightgrass" width="32" height="32" src="images/rightgrass.png">
    <img id="righttundra" width="32" height="32" src="images/righttundra.png">
    <img id="rightwater" width="32" height="32" src="images/rightwater.png">
    <img id="rightwater2" width="32" height="32" src="images/rightwater2.png">
    <img id="rightwater3" width="32" height="32" src="images/rightwater3.png">
    <img id="topbeach" width="32" height="32" src="images/topbeach.png">
    <img id="topbeach2" width="32" height="32" src="images/topbeach2.png">
    <img id="topgrass" width="32" height="32" src="images/topgrass.png">
    <img id="topleftgrass" width="32" height="32" src="images/topleftgrass.png">
    <img id="toplefttundra" width="32" height="32" src="images/toplefttundra.png">
    <img id="topleftwater" width="32" height="32" src="images/topleftwater.png">
    <img id="topleftwater2" width="32" height="32" src="images/topleftwater2.png">
    <img id="topleftwater3" width="32" height="32" src="images/topleftwater3.png">
    <img id="toprightgrass" width="32" height="32" src="images/toprightgrass.png">
    <img id="toprighttundra" width="32" height="32" src="images/toprighttundra.png">
    <img id="toprightwater" width="32" height="32" src="images/toprightwater.png">
    <img id="toprightwater2" width="32" height="32" src="images/toprightwater2.png">
    <img id="toprightwater3" width="32" height="32" src="images/toprightwater3.png">
    <img id="toptundra" width="32" height="32" src="images/toptundra.png">
    <img id="topwater" width="32" height="32" src="images/topwater.png">
    <img id="topwater2" width="32" height="32" src="images/topwater2.png">
    <img id="topwater3" width="32" height="32" src="images/topwater3.png">
    <img id="tundra" width="32" height="32" src="images/tundra.png">
    <img id="water" width="32" height="32" src="images/water.png">
    <img id="topleftbeach" width="32" height="32" src="images/topleftbeach.png">
    <img id="topleftbeach2" width="32" height="32" src="images/topleftbeach2.png">
    <img id="toprightbeach" width="32" height="32" src="images/toprightbeach.png">
    <img id="toprightbeach2" width="32" height="32" src="images/toprightbeach2.png">
    <img id="botrightbeach" width="32" height="32" src="images/botrightbeach.png">
    <img id="botrightbeach2" width="32" height="32" src="images/botrightbeach2.png">
    <img id="botleftbeach" width="32" height="32" src="images/botleftbeach.png">
    <img id="botleftbeach2" width="32" height="32" src="images/botleftbeach2.png">
    <img id="grassRocks" width="32" height="32" src="images/grassRocks.png">
    <img id="beachRocks" width="32" height="32" src="images/beachRocks.png">
    <img id="beachRocks2" width="32" height="32" src="images/beachRocks2.png">
    <img id="beachRocks3" width="32" height="32" src="images/beachRocks3.png">
    <img id="beachTexture" width="32" height="32" src="images/beachTexture.png">
    <img id="beachChest" width="32" height="32" src="images/beachChest.png">
    <img id="grassFire" width="32" height="32" src="images/grassFire.png">
    <img id="grassRock" width="32" height="32" src="images/grassRock.png">
    <img id="grassRubble" width="32" height="32" src="images/grassRubble.png">
    <img id="grassSign" width="32" height="32" src="images/grassSign.png">
    <img id="grassTree" width="32" height="32" src="images/grassTree.png">
    <img id="grassOrangeTree" width="32" height="32" src="images/grassOrangeTree.png">
    <img id="grassTrees" width="32" height="32" src="images/grassTrees.png">
    <img id="tundraChest" width="32" height="32" src="images/tundraChest.png">
    <img id="tundraFire" width="32" height="32" src="images/tundraFire.png">
    <img id="tundraGraves" width="32" height="32" src="images/tundraGraves.png">
    <img id="tundraRock" width="32" height="32" src="images/tundraRock.png">
    <img id="tundraTree" width="32" height="32" src="images/tundraTree.png">
  </head>
  <body onload = "runCode()">
    <canvas id="myCanvas" width="16384" height="16384"></canvas>
    <script>
      class MapNode { //Class for each node in the map
  constructor(height, type) {
    this.type = type;
    this.height = height;
    this.attributes = [];
  }
  getType() {
    return (this.type);
  }
  getHeight() {
    return (this.height);
  }
  addAttribute(att) {
    this.attributes.push(att);
  }
  setType(type) {
    this.type = type;
  }
  setHeight(height) {
    this.height = height;
  }
}

      class MapGenerator {
  constructor(size, parameters) {
    this.hashValues = [151, 160, 137, 91, 90, 15,
      131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,
      190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,
      88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,
      77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,
      102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,
      135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,
      5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,
      223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,
      129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,
      251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,
      49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
      138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180];
    this.size = size;
    this.parameters = parameters;
    this.map = [];

  }

  loadMap(arr,bioArr, startOffset){ //Loads data from map into an array of MapNode objects
    let length1 = arr.length;
    let length2 = arr[0].length;
    this.map = [];
    for (let i = startOffset; i < length1; i++){
      (this.map).push([]);
      for (let j = startOffset; j < length2; j++){
        (this.map[i-startOffset]).push(new MapNode(arr[i][j],bioArr[i][j]));
      }
    }
  }

  pullMap(){ //To get the map from the object
    return (this.map);
  }

  pushMap(newmap){ //To directly add a new map overwriting the main map
    this.map = newmap;
  }

  editMapNode(posX, posY, newNode){ //To directly change a map node into another (useful for editing small areas of the map without reloading the whole thing, will run faster)
    this.map[posX][posY] = newNode;
  }

  makeBiomesReadable(biomeMap, mainMap, water){ //Function to aid in the reading and creation of biomes
    let waterLevel = 0;
    if (water==false){
      waterLevel = -0.0005;
    }
    let mapLen = biomeMap.length;
    let newBiomeMap = [];
    for (let i = 0; i<mapLen; i++){
      newBiomeMap.push([]);
      for (let j = 0; j < mapLen; j++){
        if (biomeMap[i][j] == 0.001){
          newBiomeMap[i].push(1); //Biome 1
        } else if (mainMap[i][j] < 0.0039+waterLevel) {
          newBiomeMap[i].push(2); //Beach
        } else if (mainMap[i][j] < 0.0042+waterLevel) {
          newBiomeMap[i].push(3); //Water
        } else if (mainMap[i][j] < 0.00425+waterLevel) {
          newBiomeMap[i].push(2); //Beach
        } else {
          newBiomeMap[i].push(4); //Biome 2
        }
      }
    }
    return newBiomeMap;
  }

  average(arr, size){ //Gets the average of all heights nearby, allows the noise to more accurately match terrain
    let arrLen = arr.length;
    let newMap = [];
    //let newMap = Array.from({ length: arrLen }, () => (Array.from({ length: arrLen }, () => (0))));
    let counter = 0;
    for (let i = 0; i < arrLen; i++){
      newMap.push([]);
      for (let j = 0; j < arrLen; j++){
        newMap[i].push(0);
        counter = 0;
        for (let k = -size; k < size+1; k++){
          for (let l = -size; l < size+1; l++){
            if (i+k > -1 && i+k < arrLen && j+l > -1 && j+l < arrLen){
              newMap[i][j] += arr[i+k][j+l];
              counter++;
            }
          }
        }
      newMap[i][j] = arr[i][j]/counter;
      }
    }
    return newMap;
  }

  level(arr, rounding){ //Reduces the amount of heights to a set few so its more easily representable
    let arrLen = arr.length;
    for (let i = 0; i < arrLen; i++){
      for (let j = 0; j < arrLen; j++){
        arr[i][j] = Math.round(arr[i][j]*rounding)/rounding;
      }
    }
    return arr;
  }

  layerNoise(layers){ //Layers multiple noise frequencies on top of each other for more realistic terrain
    let mapArray = [];
    let temp = 0;
    for (let i = -1, row = 0; i < -0.5; i+=0.0004, row++){
      mapArray.push([]);
      for (let j = -1, col = 0; j < -0.5; j+=0.0004, col++){
        temp = mapGen.simplexNoise([i,j])+1;
        for (let layer = 0; layer < layers; layer++){
          temp += mapGen.simplexNoise([(i+1)*layer-1,(j+1)*layer-1])+1;
        }
        mapArray[row].push(temp/layers);
      }
    }  
    return mapArray;
  }
  
  arrAdd2D(arr1, arr2, avg, mirrorI, mirrorJ){ //Adds two arrays
    let length1 = arr1.length;
    let length2 = arr1[0].length;
    for (let i = 0; i < length1; i++){
      for (let j = 0; j < length2; j++){
        arr1[i][j] += arr2[(!mirrorI) ? i : length1-i-1][(!mirrorJ) ? j : length2-j-1]; //Adds array 1 to 2, with the option to add them while mirrored in either direction
        if (avg) {
          arr1[i][j] /= 2;
        }
      }
    }
    return arr1;
  }
  
  gradientCalc(hash, x, y) {
    let h = hash & 0x3F;
    let u = h < 4 ? x : y;
    let v = h < 4 ? y : x;
    return ((h & 1) ? -u : u) + ((h & 2) ? -2 * v : 2 * v);
  }

  simplexNoise(coords) {
    let n0 = 0;
    let n1 = 0;
    let n2 = 0;
    let f2D = (Math.sqrt(3) - 1) / 2; //Skewing factor
    let g2D = (3 - Math.sqrt(3)) / 6; //Unskewing factor
    let skew = (coords[0] + coords[1]) * f2D;
    let ySkew = coords[1] + skew;
    let xSkew = coords[0] + skew;
    let i = Math.floor(xSkew);
    let j = Math.floor(ySkew);
    let unskew = (i + j) * g2D;
    let bigCoord = [(i - unskew), (j - unskew)];
    let smallCoord = [(coords[0] - bigCoord[0]), (coords[1] - bigCoord[1])];
    let cornerSet = [0,1];
    if (smallCoord[0] > smallCoord[1]) {
      cornerSet = [1, 0];
    } else {
      cornerSet = [0, 1];
    }

    let coordSetTwo = [smallCoord[0] - cornerSet[0] + g2D,
    smallCoord[1] - cornerSet[1] + g2D,
    smallCoord[0] - 1 + (2 * g2D),
    smallCoord[1] - 1 + (2 * g2D)];

    let gradientIndices = [this.hashValues[i + this.hashValues[j]],
    this.hashValues[i + cornerSet[0] + this.hashValues[j + cornerSet[1]]],
    this.hashValues[i + 1 + this.hashValues[j + 1]]];

    let t0 = 0.5 - (smallCoord[0] * smallCoord[0]) - (smallCoord[1] * smallCoord[1]);
    if (t0 < 0) {
      n0 = 0;
    } else {
      t0 *= t0;
      n0 = t0 * t0 * this.gradientCalc(gradientIndices[0], smallCoord[0], smallCoord[1]); 
    }

    let t1 = 0.5 - (coordSetTwo[0] * coordSetTwo[0]) - (coordSetTwo[1] * coordSetTwo[1]);
    if (t1 < 0) {
      n1 = 0;
    } else {
      t1 *= t1;
      n1 = t1 * t1 * this.gradientCalc(gradientIndices[1], coordSetTwo[0], coordSetTwo[1]);
    }

    let t2 = 0.5 - (coordSetTwo[2] * coordSetTwo[2]) - (coordSetTwo[3] * coordSetTwo[3]);
    if (t2 < 0) {
      n2 = 0;
    } else {
      t2 *= t2;
      n2 = t2 * t2 * this.gradientCalc(gradientIndices[2], coordSetTwo[2], coordSetTwo[3]);
    }

    return 45.23065*(n0 + n1 + n2);
  }

  generateMap(method){
    console.time("Noise Layering");
    let mapArray = [];
    if (method == 1){ //Added multiple methods of generating the map, they result in different terrain formations most of the time, method 2 performs similarly (or sometimes slower, as there is a large variance in runtime of method 1) in runtime, method 3 performs significantly better but will produce a less visually pleasing result
      mapArray = mapGen.arrAdd2D(mapGen.layerNoise(Math.floor(Math.random()*24)+7),mapGen.layerNoise(Math.floor(Math.random()*5)+9), true, true, false); //Looks complicated but is actually pretty simple, adds two randomly selected layerings of noise together to form a more realistic and varied map
    } else if (method == 2) { //Method 2, many lower value noises
      mapArray = mapGen.arrAdd2D(mapGen.layerNoise(Math.floor(Math.random()*5)+12),mapGen.layerNoise(Math.floor(Math.random()*5)+12), true, true, false); 
      mapArray = mapGen.arrAdd2D(mapArray,mapGen.layerNoise(Math.floor(Math.random()*5)+12), true, false, true);
      mapArray = mapGen.arrAdd2D(mapArray,mapGen.layerNoise(Math.floor(Math.random()*5)+12), true, true, true);
    } else { //Method 3, a few lower value noises (same as method 2 but with fewer layers so that it runs faster) 
      mapArray = mapGen.arrAdd2D(mapGen.layerNoise(Math.floor(Math.random()*5)+12),mapGen.layerNoise(Math.floor(Math.random()*5)+12), true, true, false); 
      mapArray = mapGen.arrAdd2D(mapArray,mapGen.layerNoise(Math.floor(Math.random()*5)+12), true, false, true);
    }
    console.timeEnd("Noise Layering");
    console.time("Averaging");
    let newMap = mapGen.average(mapArray, 8);
    console.timeEnd("Averaging");
    console.time("leveling");
    newMap = mapGen.level(newMap, 10000);
    console.timeEnd("leveling");
    const biomeMap = mapGen.makeBiomesReadable(mapGen.level(mapGen.average(mapArray, 13), 1000),newMap, true);
    console.time("map loading");
    mapGen.loadMap(newMap, biomeMap, 13); //Loads in map removing the 13 dead pixels at the top and left of the map
    console.timeEnd("map loading");
    return [newMap,biomeMap];
  }

  decide(pixels){
    const tempGrassHolder = ["grass","grassFire","grassOrangeTree","grassRock","grassRocks","grassRubble","grassSign","grassTree","grassTrees","grassTree","grassTree","grass","grass","grass","grass","grass","grass","grass","grass","grass","grass","grass","grass","grass","grass","grassTree","grassTree","grass","grass","grass","grass","grass","grass","grass","grass","grass","grassTree","grassTree","grassTrees","grass","grass","grass","grass","grass"];
    const tempTundraHolder = ["tundra", "tundraChest", "tundraFire", "tundraGraves", "tundraRock", "tundraTree","tundraTree","tundraTree","tundra","tundra","tundra","tundra","tundra","tundra","tundra","tundra","tundra","tundra","tundra","tundra","tundraTree","tundraTree","tundra","tundra","tundra","tundra","tundra","tundra","tundra","tundra","tundra","tundra","tundra","tundra","tundra","tundra","tundra","tundra","tundra","tundra","tundra","tundra","tundra","tundra","tundra","tundra"];
    const tempBeachHolder = ["beach", "beachChest", "beachRocks", "beachRocks2", "beachRocks3", "beachTexture","beach","beach","beach","beach","beach","beach","beachTexture","beachTexture","beachTexture","beachTexture","beachTexture","beachTexture","beachTexture","beach","beach","beach","beach","beach","beach","beach","beach","beach","beach","beach","beach","beach","beach","beach","beach","beach","beach","beach","beach","beach","beach","beach","beach","beach","beach","beach", "beachRocks2", "beachRocks2", "beachRocks3", "beachRocks3"];
    if (pixels[1][1].getType() == 1){ //Grass
      if (pixels[0][1].getHeight() < pixels[1][1].getHeight()){ //Top middle higher
        if (pixels[1][0].getHeight() < pixels[1][1].getHeight()){ //Left middle higher
          //DISPLAY GRASS TOPLEFT
          return "topleftgrass";
        } else if (pixels[1][2].getHeight() < pixels[1][1].getHeight()){ //Right middle higher
          //DISPLAY GRASS TOPRIGHT
          return "botleftgrass";
        } else {
          //DISPLAY GRASS TOP
          return "leftgrass";
        }
        
      } else if (pixels[2][1].getHeight() < pixels[1][1].getHeight()) { //Bottom middle higher
        if (pixels[1][0].getHeight() < pixels[1][1].getHeight()) { //Left middle higher
          //DISPLAY GRASS BOTLEFT
          return "toprightgrass";
        } else if (pixels[1][2].getHeight() < pixels[1][1].getHeight()) { //Right middle higher
          //DISPLAY GRASS BOTRIGHT
          return "botrightgrass";
        } else {
          //DISPLAY GRASS BOT
          return "rightgrass";
        }
        
      } else if (pixels[1][2].getHeight() < pixels[1][1].getHeight()) { //Right middle higher
        //DISPLAY GRASS RIGHT
        return "botgrass"
      } else if (pixels[1][0].getHeight() < pixels[1][1].getHeight()) { //Left middle highter
        //DISPLAY GRASS LEFT
        return "topgrass";
      } else {
        //DISPLAY GRASS
        
        return tempGrassHolder[Math.floor(Math.random()*tempGrassHolder.length)];
      }
    } else if (pixels[1][1].getType() == 2) { //Beach EXPAND TO ALL BIOME VARIANTS
      if (pixels[0][1].getType() == 1){ //Top middle grassland
        if (pixels[1][0].getType() != 2) { //Middle left not same biome
          //DISPLAY TOPLEFT BEACH GRASS
          return "topleftbeach";
        } else if (pixels[1][2].getType() != 2) { //Middle right not same biome
          //DISPLAY TOPRIGHT BEACH GRASS
          return "botleftbeach";
        } else {
          //DISPLAY TOP BEACH GRASS
          return "leftbeach";
        }
        
      } else if (pixels[0][1].getType() == 4){ //Top middle tundra
        if (pixels[1][0].getType() != 2) { //Middle left not same biome
          //DISPLAY TOPLEFT BEACH TUNDRA
          return "topleftbeach2";
        } else if (pixels[1][2].getType() != 2) { //Middle right not same biome
          //DISPLAY TOPRIGHT BEACH TUNDRA
          return "botleftbeach2";
        } else {
          //DISPLAY TOP BEACH TUNDRA
          return "leftbeach2";
        }
        
      } else if (pixels[2][1].getType() == 1) { //Bot middle grassland
        if (pixels[1][0].getType() != 2) { //Middle left not same
          //DISPLAY BOTLEFT BEACH GRASS
          return "toprightbeach";
        } else if (pixels[1][2].getType() != 2) {//Middle right not same 
          //DISPLAY BOTRIGHT BEACH GRASS
          return "botrightbeach";
        } else{
          //DISPLAY BOT BEACH GRASS
          return "rightbeach";
        }
      } else if (pixels[2][1].getType() == 4) { //Bot middle tundra
        if (pixels[1][0].getType() != 2) { //Middle left not same
          //DISPLAY BOTLEFT BEACH TUNDRA
          return "toprightbeach2";
        } else if (pixels[1][2].getType() != 2) {//Middle right not same 
          //DISPLAY BOTRIGHT BEACH TUNDRA
          return "botrightbeach2";
        } else{
          //DISPLAY BOT BEACH TUNDRA
          return "rightbeach2";
        }
      } else if (pixels[1][0].getType() == 1) { //Middle left grass
        //DISPLAY LEFT BEACH GRASS
        return "topbeach";
      } else if (pixels[1][0].getType() == 4) { //Middle left tundra
        //DISPLAY LEFT BEACH TUNDRA
        return "topbeach2";
      } else if (pixels[1][2].getType() == 1) { //Middle right not same biome
        //DISPLAY RIGHT BEACH GRASS
        return "botbeach";
      } else if (pixels[1][2].getType() == 4) {
        //DISPLAY RIGHT BEACH TUNDRA
        return "botbeach2";
      } else {
        return tempBeachHolder[Math.floor(Math.random()*tempBeachHolder.length)];
      }
    } else if (pixels[1][1].getType() == 3) { //Water
      if (pixels[0][1].getType() == 2) { //Top middle beach
        if (pixels[1][0].getType() == 2) { //Left middle beach
          //DISPLAY TOPLEFT BEACH WATER
          return "topleftwater3";
        } else if (pixels[1][2].getType() == 2) { //Right middle beach
          //DISPLAY TOPRIGHT BEACH WATER
          return "botleftwater3";
        } else {
          //DISPLAY TOP BEACH WATER
          return "leftwater3";
        }
      } else if (pixels[2][1].getType() == 2) { //Bottom middle beach
        if (pixels[1][0].getType() == 2) { //Left middle beach
          //DISPLAY BOTLEFT BEACH WATER
          return "toprightwater3";
        } else if (pixels[1][2].getType() == 2) { //Right middle beach
          //DISPLAY BOTRIGHT BEACH WATER
          return "botrightwater3";
        } else {
          //DISPLAY BOT BEACH WATER
          return "rightwater3";
        }
      } else if (pixels[1][0].getType() == 2) { //Left middle beach
        //DISPLAY LEFT BEACH WATER
        return "topwater3";
      } else if (pixels[1][2].getType() == 2) { //Right middle beach
        //DISPLAY RIGHT BEACH WATER
        return "botwater3";
      } else {
        //DISPLAY WATER
        return "water";
      }
    } else if (pixels[1][1].getType() == 4) { //Tundra
      if (pixels[0][1].getHeight() > pixels[1][1].getHeight()){ //Top middle higher
        if (pixels[1][0].getHeight() > pixels[1][1].getHeight()){ //Left middle higher
          //DISPLAY TUNDRA TOPLEFT
          return "toplefttundra";
        } else if (pixels[1][2].getHeight() > pixels[1][1].getHeight()){ //Right middle higher
          //DISPLAY TUNDRA TOPRIGHT
          return "botlefttundra";
        } else {
          //DISPLAY TUNDRA TOP
          return "lefttundra";
        }
        
      } else if (pixels[2][1].getHeight() > pixels[1][1].getHeight()) { //Bottom middle higher
        if (pixels[1][0].getHeight() > pixels[1][1].getHeight()) { //Left middle higher
          //DISPLAY TUNDRA BOTLEFT
          return "toprighttundra";
        } else if (pixels[1][2].getHeight() > pixels[1][1].getHeight()) { //Right middle higher
          //DISPLAY TUNDRA BOTRIGHT
          return "botrighttundra";
        } else {
          //DISPLAY TUNDRA BOT
          return "righttundra";
        }
        
      } else if (pixels[1][2].getHeight() > pixels[1][1].getHeight()) { //Right middle higher
        //DISPLAY TUNDRA RIGHT
        return "bottundra";
      } else if (pixels[1][0].getHeight() > pixels[1][1].getHeight()) { //Left middle highter
        //DISPLAY TUNDRA LEFT
        return "toptundra";
      } else {
        //DISPLAY TUNDRA
        return tempTundraHolder[Math.floor(Math.random()*tempTundraHolder.length)];
      }
    } else {
        return "water";
    }
  }  
}

      function runCode(){
  var canvas = document.getElementById("myCanvas");
  var ctx = canvas.getContext("2d", { alpha: false });
  let answer = "";
  
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  mapGen = new MapGenerator(1200,[""]);
  let [newMap,biomeMap] = mapGen.generateMap(1);
  let img = document.getElementById("grass");
  let tempDefiner = new MapNode(0,0);
  let pixelList = [[tempDefiner,tempDefiner,tempDefiner],[tempDefiner,tempDefiner,tempDefiner],[tempDefiner,tempDefiner,tempDefiner]];
  let mapFinal = mapGen.pullMap();
  for (let i=0; i<512; i++){
    for (let j=0; j<512; j++){
      for (let m = -1; m < 2; m++){
        for (let n = -1; n < 2; n++){
          if (i+m >= 0 && j+n >= 0 && j+n <= 512 && i+m <= 512){
            pixelList[m+1][n+1] = mapFinal[i+m][j+n];
          } else {
            pixelList[m+1][n+1] = new MapNode(0.004,4); //Defines nodes outside the bound to be water
          }
        }
      }
      answer = mapGen.decide(pixelList);
      img = document.getElementById(answer);
      //console.log(img + " " + answer);
      if (img != null){
        ctx.drawImage(img, i*32, j*32);
      }
    }
  }
         console.log("rendered");
}
     
    </script>
    
  </body>
</html>
